	p68h11

DDRC	equ	$1007	;data direction register for C
PIOC	equ	$1002	;for strobe B assertion change
PORTCL	equ	$1005	;port C latched
PORTB	equ	$1004	;port B



	ORG	$0100


mensaje	FCC	'BUEN DIA GRUPO'	;mensaje a mostrar
	FCB	0		;coloco el terminador nulo

LEFT	EQU	0		<- [display] <- texto
RIGHT	EQU	1		texto -> [display] ->

SENTIDO	EQU	RIGHT		colocar el sentido en el que aparece el texto




* FADE IN FROM RIGHT (efecto de display)
* Recibe por Y la posición de una cadena de 4 caracteres
* Ingresa la cadena desde la izquierda del display de manera secuencial

	ORG	$0000
f_in_L	EQU	*
	pshx		backup de X
	pshy		Guardo el valor de la posición de la cadena
	tsx		X=SP+1
	psha
	pshb

	jsr	clear		borro el display
	jsr	delay		delay

	ldab	#3		repeticiones del contador
borra_1	equ	*
	tab			A=B	
	sba			A=A-B	
	deca
	bpl	borra_1


	pulb
	pula
	puly
	pulx
	rts



*************************************************************************
*		println	(PRINT LINE)					*
* Descripción:								*
*	Imprime en el display 4 caracteres consecutivos a una posición 	*
* de memoria								*
*									*
* Params:								*
* 	- [AccY]: Pos. de memoria del primer caracter de la cadena de 4	*
*		caracteres que desea imprimir				*
* 									*
* Nota: no devuelve valores, deja el AccY con el valor que tenía	*
*	antes de ejecutar la subrutina					*
*************************************************************************

println	equ	*
	pshy		backup Y
	psha		backup A
	pshb		backup B

	ldab	#3	;inicio B en 3
repite	equ	*
	ldaa	0,y	;leo el caracter en cuestion
	stab	PORTCL	;set the position 0-3
	staa	PORTB	;set the character
	iny

	decb
	bpl	repite	;si B >= 0 repite

	pulb		recupero backup B
	pula		recupero backup A
	puly		recupero backup Y
	rts


*********************************************************
*		CLEAR					*
* Descripción:						*
*	Borra el contenido del display y del vector	*
*	usado como variable global del display		*
*							*
* Nota: no devuelve valores ni recibe parámetros 	*
*********************************************************
clear	equ	*
	psha			backup de A
	pshb			backup de B

	ldab	#3		cantidad de ciclos menos 1 (porque cuento el cero)
L05	ldaa	#' '		cargo un espacio
	jsr 	outchar		lo escribo en el display
	decb			decremento el indice
	bpl	L05		si es positivo o cero, repito (asi puedo usar el cero)

	pulb			
	pula
	rts			retorno de la subrutina



*********************************************************
*		SUBRUTINA STRLEN			*
* Esta subrutina devuelve por el [registro B], el largo	*
* de una cadena de texto con terminador nulo, cuya 	*
* dirección de memoria es pasada como parámetro		*
* por el [registro X]					*
*							*
* Input:  [AccIX]: dirección de memoria de la cadena	*
* Output: [AccB]: largo de la cadena sin contar el term *
*							*
* Nota: El máximo de la cadena es de 255 con el		*
*	terminador, si la cadena no presenta terminador	*
*	nulo, devuelve el overflow en 1			*
*********************************************************
strlen	EQU	*
	psha			backup de A
	pshx			backup de X
	
	ldab	#$FF		Cargo las repeticiones del contador en B

busca	ldaa	0,x		Leo el caracter actual
	beq	found		Si es cero, significa que es el terminador nulo
	inx			Si no es, voy a la siguiente posición de la cadena
	decb			Decremento el contador de cantidad de repeticiones
	bne	busca		Si no es cero, repite la búsqueda del caracter NULL

	sev			si no encontré el terminador, seteo el overflow en 1
	bra	return		salgo

found	comb			Invierto el valor de B para obtener la cantidad de caracteres contados
*				('comb' devuelve overflow en 0 siempre)

	pulx			recupero backup de X
return	pula			recupero backup de B
 	rts



*********************************************************
*		SUBRUTINA delay				*
*							*
* Esta subrutina genera un delay de aprox 500 ms para	*
* el procesador M68HC11E				*
* No recibe ningún parámetro ni retorna valores, no 	*
* hace falta liberar el stack depués de invocarla	*
*********************************************************

* org	$2100
delay	equ	*
	pshx			Hago backup de los registros	(4 ciclos)
	pshy							(5 ciclos)
	psha							(3 ciclos)
	pshb							(3 ciclos)
	ldaa	#20		Cargo la cantidad de repeticiones que haré con el loop1. (20 ciclos)
*								[TOTAL:17]

*	[LOOP1]: n recorridos del loop1 lleva n*(9+T) ciclos, siendo T los ciclos en total del loop2. 
loop1	ldy	#$D900		Cargo la cantidad de repeticiones que haré con el loop2. (4 ciclos)

* 	[LOOP2]: Un solo recorrido del loop2 lleva 9 ciclos, 55552 ($D900) recorridos del loop2 lleva 499968 ciclos
loop2	nop			retardo 		(2 ciclos)
	dey			decremento Y 		(4 ciclos)
	bne	loop2		salto si no es cero 	(3 ciclos)
*							[TOTAL:9]

	deca			decremento A	(2 ciclos)
	bne	loop1		si A!=0, repito (3 ciclos)


	ldy	#$12		Retardo 			(5 ciclos)
	pulb			Recupero el valor 		(4 ciclos)
	pula			de los	registros		(4 ciclos)
	puly							(6 ciclos)
	pulx							(5 ciclos)
	rts			Retorno de la rubrutina		(5 ciclos)
*								[TOTAL:29]





*****************************************
*	outchar				*
* ACCA: Carácter a enviar		*
* ACCB: Posición	(0-3)		*
*****************************************
outchar	equ	*
	stab	PORTCL	;set the position
	staa	PORTB	;set the character
	rts

*****************************************
*	initdis				*
* Inicia el display			*
*****************************************

initdis	equ	*
	psha
	ldaa	#$FF	;set for output
	staa	DDRC	;C output
	ldaa	PIOC	;get current value
	anda	#$FE	;reset bit 0 to 0
	staa	PIOC	;send it out
	pula
	rts


*****************************************
*	STACK DATA			*
*****************************************

	ORG	$3000
stack	RMB	100
stk_ini	EQU	*-1



	END