*****************************************************************************************************************
*		TP2	EJERCICIO 2			GRUPO B5						*
*														*
* Consigna:													*
*	Escribir una rutina que encuentre el mayor de los elementos del array del ejercicio anterior		*
*	formado por elementos de 1 byte. Indicar los cambios que se deberían hacerse en el código		*
*	para que la rutina escrita se pueda utilizar para encontrar el elemento mayor del arreglo de 2		*
*	bytes cada uno (Se deberían hacer menos de 5 modificaciones en el código).				*
*****************************************************************************************************************
	p68h11

*********************************************************
*		ESTRUCTURA DE DATOS			*
* En esta seccion se definen la estructura del array 1	*
* y del array 2						*
*********************************************************
ARR_1 	equ 	$3000		posición inicial del primer array
N_1 	equ 	6		cantidad de elementos del array
SIZE_1	equ	1		tamaño de cada elemento (en bytes)

ARR_2 	equ 	$3010		posición inicial del primer array
N_2	equ 	6		cantidad de elementos del array
SIZE_2	equ	2		tamaño de cada elemento (en bytes)


STK_POS	equ	$3500		posición del fin de stack
STKSIZE	equ	32		tamaño del stack



	org	$2000
main	equ	*
	ldx	#ARR_1		cargo la dirección en memoria del array
	ldaa	#N_1		cargo el largo del array (elementos)
	ldab	#SIZE_1		cargo el tamaño de cada elemento del array
	pshx			paso por stack la dirección
	psha			paso por stack el largo del array
	pshb			paso por stack el tamaño de los elementos

	jsr	getMax8		Invoco la subrutina para obtener el máximo de los elementos de 8 bits
	
	pulx			libero 2 bytes del stack
	pulx			guardo en X la dirección de memoria del mayor de los elementos

	ldaa	0,X		guardo en A el elemento mayor

fin	jmp	fin

*****************************************************************************************
*				SUBRUTINA GETMAX8					*
* Función: Obtener el valor máximo de un arreglo de elementos numéricos no signados	*
*	de 8 bits									*
*											*
* Inputs (via stack): 									*
* 	1) Dirección inicial de memoria del array (2 bytes)				*
*	2) Cantidad de elementos del array (1 byte)					*
*	3) Tamaño de cada elemento (1 byte)						*
* Outputs (via stack):									*
*	1) VACIO (2 bytes) - se deben liberar estos bytes				*
*	2) Dirección de memoria del mayor elemento del array (2 bytes)			*
*											*
*****************************************************************************************

* [YH	]
* [YL	]
* [B	]
* [A	]
* [idx ] 0 <-(X)
* [XH	] 1
* [XL	] 2	
* [PCH	] 3	
* [PCL	] 4
* [el_size] 5
* [arr_len] 6
* [arr_pos H] 7
* [arr_pos L] 8

	ORG	$2300
getMax8	EQU	*
	pshx			backup del registro X
	des			guardo espacio para una variable local de 1 byte
	tsx			X=SP+1
	psha			backup del registro A
	pshb			backup del registro B
	pshy			backup del registro Y

	ldaa	6,x		cargo repeticiones del contador (arr_len)
	staa	0,x		para guardarlas en la variable local

loop	equ	*
	ldy	7,x		cargo la posición inicial del array (Y = arr_pos)
	ldab	5,x		cargo el tamaño de los elementos del array (B = el_size)
	ldaa	0,x		cargo la posición actual del array (A = index)
	mul			D = A*B (offset de posicion con respecto a la inicial)
	aby			agrego el offset de posición a Y
 	ldaa	0,y		Leo el elemento del array


	
	dec	0,x		decremento var1 (contador del loop)
	bne	loop

	puly
	pulb
	pula
	des		decremento el stack para liberar la variable
	pulx
	rts


*********************************************************
*		AREA DE MEMORIA				*
* En esta seccion se reservan las posiciones de memoria	*
* usadas por los arrays					*
*********************************************************
	org 	ARR_1
arr_1 	rmb 	SIZE_1*N_1	reservo bytes para el primer array

	org 	ARR_2
arr_2 	rmb 	SIZE_2*N_2	reservo bytes para el segundo array


*********************************************************
*		AREA DE DATOS				*
* En esta sección se inicializan los arreglos		*
*********************************************************
	org 	ARR_1
datos1	FCB	12,15,94,20,15,45
	org 	ARR_2
datos2	FDB	1200,1235,44694,11920,50915,45


	ORG	STK_POS
stack	RMB	STKSIZE
stk_ini	EQU	*-1

	END